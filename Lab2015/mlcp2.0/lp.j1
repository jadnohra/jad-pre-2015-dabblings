# http://learnxinyminutes.com/docs/julia/
# István Maros. Computational Techniques of the Simplex Method. Kluwer Academic Publishers, Boston, 2003. [CTSM]
# Robert J. Vanderbei. Linear Programming: Foundations and Extensions. Springer, second edition, 2001. [LPFE]

#= 
	Solve, Revised, Simplex. lp_solve_rsimplex
	1. revised simplex, basis inversion, no reuse
	2. revised simplex, basis factorization, no reuse
	3. revised simplex, basis factorization, reuse, no re-factorization
	4. revised simplex, basis factorization, reuse, re-factorization
	5. revised simplex, basis factorization, reuse, re-factorization, degen, sing
	
	Solve, Revised, Sparse. solve_srsimplex
	1. revised sparse simplex

	Presolve
	1. ??
=#


module lp

	type canonical_problem
		numtype::String
		n::Int
		m::Int
		c#::Array{Any, 1}
		A#::Array{Any, 2}
		b#::Array{Any, 1}

		canonical_problem() = new()
	end

	type solution
		solved::Bool
		data

		solution() = ( x = new(); x.solved = false; return x; )
	end	

	function conv_vec(numtype, V)
		n = length(V)
		ret = eval(parse( "Array($numtype, $n)" ))
		for i = 1:n 
			ret[i] = eval(parse("convert($(numtype), $V[$i])"))
		end
		return ret
	end

	function conv_mat(numtype, M)
		r = size(M)[1]; c = size(M)[2];
		ret = eval(parse( "Array($numtype, ($r, $c))" ))
		for i = 1:length(M)
			ret[i] = eval(parse("convert($(numtype), $M[$i])"))
		end
		return ret
	end

	function create_max_problem(numtype, c, A, b)
		ret = canonical_problem()
		ret.numtype = numtype
		ret.n = length(c)
		ret.m = length(b)
		ret.c = vcat( conv_vec(numtype, c), eval(parse( "zeros($numtype, $(ret.m))" )) ) 
		ret.A = hcat( conv_mat(numtype, A), conv_mat(numtype, eye(ret.m)) )
		ret.b = conv_vec(numtype, b)
		return ret
	end

	function create_min_problem(numtype, c, A, b) return create_max_problem(numtype, -1*(c), A, b) end

	problem_db = Function[]

	function problem_simple(numtype) 
		create_min_problem(numtype, [1, 1], [2 3;], [10]) 
	end; push!(problem_db, problem_simple)

	function problem_LPFE_p88(numtype)	
		create_min_problem(numtype, [4,3], [1 -1; 2 -1; 0 1], [1, 3, 5])
	end; push!(problem_db, problem_LPFE_p88)

end


module lp_rsimplex_algo1
	using lp

	type working_data
		prob::lp.canonical_problem
		n::Int
		m::Int
		iB::Array{Int, 1}
		iR::Array{Int, 1}
		B#::Array{numtype, 2}
		Binv#::Array{numtype, 2}
		R#::Array{numtype, 2}
		xB#::Array{numtype, 1}
		πT#::Array{numtype, 1}
		cBT#::Array{numtype, 1}
		dJ#::Array{numtype, 1}
		αq#::Array{numtype, 1}
		zero
		mEye

		working_data() = new()
	end

	function create_data(prob)
		ret = working_data()
		ret.prob = prob
		ret.n = prob.n 
		ret.m = prob.m
		ret.iB = Array(Int, prob.m)
		ret.iR = Array(Int, prob.n)
		numtype = prob.numtype; n = prob.n; m = prob.m;
		ret.B = eval(parse( "Array($numtype, ($m,$m))" ))
		#ret.Binv = eval(parse( "Array($numtype, ($m,$m))" ))
		ret.R = eval(parse( "Array($numtype, ($m,$n))" ))
		ret.xB = eval(parse( "Array($numtype, $m)" ))
		#ret.πT = eval(parse( "Array($numtype, $m+$n)" ))
		#ret.cBT = eval(parse( "Array($numtype, $m)" ))
		ret.dJ = eval(parse( "Array($numtype, $n)" ))
		#ret.αq = eval(parse( "Array($numtype, $n)" ))
		ret.zero = eval(parse( "zero($numtype)" ))
		ret.mEye = lp.conv_mat(prob.numtype, eye(m))
		return ret
		123
	end	

	function split_cols(S, T1, T2, iT1)
		i1 = 1; Tc1 = 1; Tc2 = 1;
		for c = 1:size(S)[2]
			if length(iT1) >= i1 && c == iT1[i1]
				T = T1; Tc = Tc1; Tc1 = Tc1+1; i1 = i1 + 1;
			else
				T = T2; Tc = Tc2; Tc2 = Tc2+1; 
			end
			for r = 1:size(S)[1]
				T[r, Tc] = S[r, c]
			end	
		end
	end

	function set_basis_logical(data)
		data.iB = [i for i in data.n+1:data.n+data.m]
		data.iR = [i for i in 1:data.n]
	end

	function update_B_R(data) split_cols(data.prob.A, data.B, data.R, data.iB) end
	function update_Binv(data) data.Binv = inv(data.B) end
	function update_xB(data) data.xB = data.Binv * (data.prob.b) end
	function update_cBT(data) data.cBT = transpose(data.prob.c[data.iB]) end
	function update_πT(data) data.πT = reshape(data.cBT * data.Binv, length(data.cBT)); end
	function calc_dj(data, j) i = data.iR[j]; dj = data.prob.c[i] - dot(data.πT, data.prob.A[:,i]); return dj; end	
	function update_dJ(data) for j = 1:data.n data.dJ[j] = calc_dj(data, j) end; end	
	function update_αq(data, q) data.αq = data.Binv * (data.mEye[:,q]) end
	function check_optimal_dJ(data) return all( dj->( dj >= data.zero), data.dJ); end

	function price_full_dantzig(data)
		# [CTSM].p187
		min_i = 0; min_dj = data.zero;
		for i = 1:length(data.dJ)
			dj = data.dJ[i]
			if (dj < data.zero && dj <= min_dj)
				if (dj == min_dj)
					println("Warning: degeneracy.")
				end	
				min_i = i; min_dj = dj;
			end	
		end
		return min_i
	end	

	function chuzro(data)
		min_i = 0; min_ratio = data.zero;
		for i = 1:length(data.αq)
			if (data.αq[i] > data.zero)
				ratio = data.xB[i] / data.αq[i]
				if (min_i == 0 || ratio <= min_ratio)
					if (ratio == min_ratio)
						println("Warning: degeneracy.")
					end	
					min_i = i; min_ratio = ratio;
				end
			end
		end
		return min_i
	end

	function solve_data(data)
		# [CTSM].p33
		sol = lp.solution(); sol.data = data;
		set_basis_logical(data)
		update_B_R(data) 
		update_Binv(data)
		update_xB(data)
		#todo phaseI
		update_cBT(data)
		update_πT(data)
		update_dJ(data)
		if check_optimal_dJ(data)
			sol.solved = true
			return sol
		end
		q = price_full_dantzig(data)
		update_αq(data, q)
		p = chuzro(data)
		if (p == 0)
			println("Unbounded")
			sol.solved = false
			return sol
		end

		@printf "p:%d q:%d \n" p q
		println(data.αq)

		return sol
	end

	function solve_problem(problem) return solve_data(create_data(problem)) end

end

function test(i = 1, numtype = "Float32")
	prob = lp.problem_db[i](numtype)
	sol = lp_rsimplex_algo1.solve_problem(prob)
	return sol
end
